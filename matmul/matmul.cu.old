#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>
#include <iostream>

using namespace std;

__global__ void simple_kernel(const float *X, const float *W, float *Y, const int N) {
    const int x = blockIdx.x * 16 + threadIdx.x;
    const int y = blockIdx.y * 16 + threadIdx.y;

    __shared__ float L[16][16];
    __shared__ float R[16][16];

    float tmp = 0.0f;
    for (int tile = 0; tile < N/16; tile++) {
        L[threadIdx.y][threadIdx.x] = X[y * N + (tile * 16 + threadIdx.x)];
        R[threadIdx.y][threadIdx.x] = W[x * N + (tile * 16 + threadIdx.y)];

        __syncthreads();
        for (int k = 0; k < 16; k++) {
            tmp += L[threadIdx.y][k] * R[k][threadIdx.x];
        }
        __syncthreads();
    }

    Y[y * N + x] = tmp;
}

int main() {
    const int N = 512;
    float *A, *B, *C;

    cudaMalloc((void **) &A, N * N * sizeof(float));
    cudaMalloc((void **) &B, N * N * sizeof(float));
    cudaMalloc((void **) &C, N * N * sizeof(float));

    float *A_cpu = (float *) malloc(N * N * sizeof(float));
    float *B_cpu = (float *) malloc(N * N * sizeof(float));
    float *C_cpu = (float *) malloc(N * N * sizeof(float));
    float *D_cpu = (float *) malloc(N * N * sizeof(float));

    for (int i = 0; i < N * N; i++) {
        A_cpu[i] = (float) rand() / (float) RAND_MAX - 0.5;
        B_cpu[i] = (float) rand() / (float) RAND_MAX - 0.5;
    }

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            float tmp = 0;
            for (int k = 0; k < N; k++) {
                tmp += A_cpu[i * N + k] * B_cpu[j * N + k];
            }
            C_cpu[i * N + j] = tmp;
        }
    }

    cudaMemcpy((void *) A, (void *) A_cpu, N * N * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpy((void *) B, (void *) B_cpu, N * N * sizeof(float), cudaMemcpyHostToDevice);


//    myGEMM8<<<blocks, threads>>>((const floatX*) A,(const floatX*) B, C);
    simple_kernel << < dim3(N / 16, N / 16), dim3(16, 16) >> > (A, B, C, N);

//    dim3 blocks(N / 128, N / 128, 1);
////    dim3 threads(TSM/WPTM, TSN/WPTN);
//    fast_kernel<128, 8> << < blocks, dim3(16, 16) >> > ((const floatX *) A, (const floatX *) B, C, N);
//    //myGEMM8<< < blocks, dim3(16, 16) >> > ((const floatX *) A, (const floatX *) B, C);


    cudaMemcpy((void *) D_cpu, (void *) C, N * N * sizeof(float), cudaMemcpyDeviceToHost);

    float err = 0;
    for (int i = 0; i < N * N; i++) {
        err += pow(C_cpu[i] - D_cpu[i], 2);
    }

    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 6; j++) cout << C_cpu[(i) * N + (249 + j)] << " ";
        cout << endl;
    }
    cout << endl;
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 6; j++) cout << D_cpu[(i) * N + (249 + j)] << " ";
        cout << endl;
    }
    cout << endl;

    cout << "Error: " << err << endl;

}